/**
     * Create bubbles periodically regardless of movement
     */
    function spawnBubblesAutomatically() {
      // Generate 1-2 bubbles every call
      const bubbleCount = Math.floor(Math.random() * 2) + 1;
      
      // Get the current narwhal position
      const rect = narwhal.getBoundingClientRect();
      
      // Determine if the narwhal is facing right or left based on current transform
      const transform = window.getComputedStyle(narwhal).transform;
      const isMovingRight = !transform.includes('-1');
      
      // Create the bubbles
      for (let i = 0; i < bubbleCount; i++) {
        // Slight delay between bubbles if more than one
        setTimeout(() => {
          createTinyBubble(narwhal, rect, isMovingRight);
        }, i * 100);
      }
    }
    
    /**
     * Start automatic bubble generation
     */
    function startAutoBubbles() {
      // Generate bubbles every 2-4 seconds
      autoBubbleInterval = setInterval(() => {
        spawnBubblesAutomatically();
      }, Math.random() * 2000 + 2000);
    }
    
    // ==========================================================================
    // API INTERACTION FUNCTIONS
    // ==========================================================================
    
    /**
     * Load event details from the API
     */
    function loadEventDetails() {
      fetch(`${SCRIPT_URL}?action=getEventDetails`)
        .then(response => {
          if (!response.ok) {
            throw new Error('Network response was not ok');
          }
          return response.json();
        })
        .then(details => {
          displayEventDetails(details);
        })
        .catch(error => {
          console.error("Error loading event details:", error);
          // Use fallback data
          displayEventDetails(getFallbackEventDetails());
        });
    }
    
    /**
     * Fallback event details in case API fails
     */
    function getFallbackEventDetails() {
      return {
        TITLE: "Callie's Birthday Celebration",
        DATE: "Saturday, April 28, 2025",
        TIME: "12:00 PM - 2:00 PM",
        LOCATION: "Kenwood Baptist Church - Pavillion",
        LOCATION_LINK: "https://maps.app.goo.gl/eqZJb2o5WgAAMCZb7",
        DESCRIPTION: "We are parked towards the back of the building (outside) in the pavillion area!",
        GIFT_INFO: "No gifts are necessary, just your presence is required! If you insist on bringing Callie a gift, clothes are preferred because God has blessed her with plenty of toys already!",
        DRESS_CODE: "Casual outdoor attire",
        ADDITIONAL_INFO: "We'll have a thematic race and other games so bring your game faces!"
      };
    }
    
    /**
     * Display event details in the UI
     */
    function displayEventDetails(details) {
      // Update the main header
      eventTitleHeader.textContent = details.TITLE || "Event Details";
      eventDescShort.textContent = details.DESCRIPTION || "Join us for this special event!";
      
      // Update the essential info (always visible)
      document.getElementById('event-title').textContent = details.TITLE || "";
      document.getElementById('event-date').textContent = details.DATE || "";
      document.getElementById('event-time').textContent = details.TIME || "";
      document.getElementById('event-location').textContent = details.LOCATION || "";
      
      // Update the expandable details
      document.getElementById('event-description').textContent = details.DESCRIPTION || "";
      
      if (document.getElementById('event-gift-info').querySelector('span')) {
        document.getElementById('event-gift-info').querySelector('span').textContent = details.GIFT_INFO || "";
      }
      
      if (document.getElementById('event-dress-code').querySelector('span')) {
        document.getElementById('event-dress-code').querySelector('span').textContent = details.DRESS_CODE || "";
      }
      
      document.getElementById('event-additional-info').textContent = details.ADDITIONAL_INFO || "";
      
      // Set location link if available
      const locationLink = document.getElementById('location-link');
      if (details.LOCATION_LINK) {
        locationLink.href = details.LOCATION_LINK;
        locationLink.style.display = "inline";
      } else {
        locationLink.style.display = "none";
      }
      
      // Hide empty sections in the additional details
      const allExpandableDetails = document.querySelectorAll('.event-details-content .event-detail');
      allExpandableDetails.forEach(detail => {
        // Check if the detail has content (either directly or in a span)
        const span = detail.querySelector('span');
        const content = span ? span.textContent : detail.textContent;
        
        if (!content || content.trim() === "" || content === "Loading...") {
          detail.style.display = "none";
        }
      });
    }
    
    /**
     * Setup event details panel toggle
     */
    function setupEventDetailsToggle() {
      const panel = document.querySelector('.event-details-panel');
      const panelHeader = panel.querySelector('h3');
      
      // Toggle on header click or header button click
      headerToggleBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        toggleDetailsPanel();
      });
      
      panelHeader.addEventListener('click', function() {
        toggleDetailsPanel();
      });
      
      // Toggle on button click inside expanded view
      detailsToggleBtn.addEventListener('click', function() {
        toggleDetailsPanel();
      });
      
      function toggleDetailsPanel() {
        panel.classList.toggle('event-details-collapsed');
        updateToggleButtonsText();
      }
      
      function updateToggleButtonsText() {
        if (panel.classList.contains('event-details-collapsed')) {
          headerToggleBtn.textContent = "Show More";
          detailsToggleBtn.textContent = "Hide Details";
        } else {
          headerToggleBtn.textContent = "Hide";
          detailsToggleBtn.textContent = "Hide Details";
        }
      }
      
      // Initialize the toggle button text
      updateToggleButtonsText();
    }
    
    /**
     * Load existing RSVPs from the API
     */
    function loadExistingRsvps() {
      fetch(`${SCRIPT_URL}?action=getExistingRsvps`)
        .then(response => {
          if (!response.ok) {
            throw new Error('Network response was not ok');
          }
          return response.json();
        })
        .then(rsvps => {
          if (rsvps && rsvps.length > 0) {
            // Create bubbles for each RSVP
            rsvps.forEach(rsvp => {
              // Only create bubbles for "Yes" responses
              if (rsvp.attending === "Y") {
                createBubble(rsvp.name, rsvp.status === "Confirmed");
              }
            });
          } else {
            // Create sample bubbles if no RSVPs
            createSampleBubbles();
          }
        })
        .catch(error => {
          console.error("Error loading RSVPs:", error);
          // Create sample bubbles on error
          createSampleBubbles();
        });
    }
    
    /**
     * Create sample bubbles for testing/preview
     */
    function createSampleBubbles() {
      const sampleNames = ["Jane Smith", "John Doe", "Alex Johnson", "Samantha Lee"];
      sampleNames.forEach((name, index) => {
        createBubble(name, index < 2);
      });
    }
    
    /**
     * Check for confirmed RSVPs
     */
    function checkForConfirmedRsvps() {
      fetch(`${SCRIPT_URL}?action=getConfirmedRsvps`)
        .then(response => {
          if (!response.ok) {
            throw new Error('Network response was not ok');
          }
          return response.json();
        })
        .then(confirmedNames => {
          if (confirmedNames && confirmedNames.length > 0) {
            confirmedNames.forEach(name => {
              confirmBubble(name);
            });
          }
        })
        .catch(error => {
          console.error("Error checking confirmed RSVPs:", error);
        });
    }
    
    // ==========================================================================
    // BUBBLE CREATION FUNCTIONS
    // ==========================================================================
    
    /**
     * Check if two bubbles overlap
     */
    function doCirclesOverlap(x1, y1, r1, x2, y2, r2) {
      // Calculate distance between centers
      const dx = x1 - x2;
      const dy = y1 - y2;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // Add some padding to make sure bubbles aren't too close
      const minDistance = r1 + r2 + 10;
      
      return distance < minDistance;
    }
    
    /**
     * Find a non-overlapping position for a new bubble
     */
    function findNonOverlappingPosition(size) {
      const containerWidth = bubbleContainer.clientWidth;
      const containerHeight = bubbleContainer.clientHeight;
      
      // Define the area bounds where bubbles can be placed (in px)
      // Add some padding from edges to prevent bubbles being cut off
      const padding = 20;
      const minLeft = size / 2 + padding;
      const maxLeft = containerWidth - size / 2 - padding;
      const minTop = size / 2 + padding;
      const maxTop = containerHeight - size / 2 - padding;
      
      let attempts = 0;
      let maxAttempts = 100; // Prevent infinite loop
      
      while (attempts < maxAttempts) {
        // Generate random position in pixels
        const left = Math.floor(Math.random() * (maxLeft - minLeft)) + minLeft;
        const top = Math.floor(Math.random() * (maxTop - minTop)) + minTop;
        
        let overlaps = false;
        
        // Check against all existing bubbles
        for (const bubble of existingBubbles) {
          const bubbleSize = parseInt(bubble.style.width, 10);
          const bubbleLeft = parseFloat(bubble.style.left) / 100 * containerWidth;
          const bubbleTop = parseFloat(bubble.style.top) / 100 * containerHeight;
          
          if (doCirclesOverlap(left, top, size / 2, bubbleLeft, bubbleTop, bubbleSize / 2)) {
            overlaps = true;
            break;
          }
        }
        
        // If no overlap, return this position
        if (!overlaps) {
          return {
            left: (left / containerWidth) * 100, // Convert back to percentage
            top: (top / containerHeight) * 100   // Convert back to percentage
          };
        }
        
        attempts++;
      }
      
      // If we couldn't find a non-overlapping position, return a fallback
      console.log("Could not find non-overlapping position after " + maxAttempts + " attempts");
      return {
        left: Math.random() * 70 + 15, // Adding more margin to edges
        top: Math.random() * 70 + 15   // Adding more margin to edges
      };
    }
    
    /**
     * Create a bubble with fluid animation
     */
    function createBubble(name, isConfirmed = false) {
      // Randomize bubble size for more natural look
      const size = Math.floor(Math.random() * 40) + 80; // between 80px and 120px
      
      // Find a non-overlapping position
      const position = findNonOverlappingPosition(size);
      
      const bubble = document.createElement("div");
      bubble.className = "bubble";
      bubble.setAttribute("data-name", name);
      
      // Add confirmed class if needed
      if (isConfirmed) {
        bubble.classList.add("confirmed");
      }
      
      // Create and append the text span
      const textSpan = document.createElement("span");
      textSpan.className = "bubble-text";
      textSpan.textContent = name;
      bubble.appendChild(textSpan);
      
      // Set position and size
      bubble.style.top = position.top + "%";
      bubble.style.left = position.left + "%";
      bubble.style.width = size + "px";
      bubble.style.height = size + "px";
      
      // Apply appropriate animation
      if (isConfirmed) {
        // Apply simple up/down bobbing animation for confirmed bubbles
        bubble.style.opacity = "0.5"; // Make it faded
        bubble.style.animation = "bobUpDown 3s ease-in-out infinite";
      } else {
        // Apply full fluid animation for regular bubbles
        applyCustomAnimation(bubble, size);
      }
      
      // Add to container
      bubbleContainer.appendChild(bubble);
      
      // Add to existing bubbles array for collision detection
      existingBubbles.push(bubble);
      
      return bubble;
    }
    
    /**
     * Apply animation based on bubble size
     */
    function applyCustomAnimation(bubble, size) {
      // Different animation based on size
      let animationName;
      if (size < 95) {
        animationName = "floatSmall";
      } else if (size > 115) {
        animationName = "floatLarge";
      } else {
        // For medium size bubbles, pick one of the three variations
        const variations = ["float1", "float2", "float3"];
        animationName = variations[Math.floor(Math.random() * variations.length)];
      }
      
      // Random duration between 8 and 15 seconds
      const duration = (Math.random() * 7 + 8).toFixed(1);
      
      // Random delay so bubbles don't all move in sync
      const delay = (Math.random() * 5).toFixed(1);
      
      // Apply the animation with cubic-bezier for more natural movement
      bubble.style.animation = `${animationName} ${duration}s cubic-bezier(0.45, 0.05, 0.55, 0.95) ${delay}s infinite`;
    }
    
    /**
     * Mark a bubble as confirmed
     */
    function confirmBubble(name) {
      // Find the bubble with the matching name
      const bubbles = document.querySelectorAll('.bubble');
      bubbles.forEach(bubble => {
        if (bubble.getAttribute("data-name") === name && !bubble.classList.contains("confirmed")) {
          // Apply popping animation temporarily
          bubble.style.animation = 'popEffect 0.5s forwards';
          
          // After animation completes, add the confirmed class and apply bobbing animation
          setTimeout(() => {
            bubble.classList.add("confirmed");
            bubble.style.opacity = "0.5"; // Make it faded
            bubble.style.animation = "bobUpDown 3s ease-in-out infinite";
          }, 500);
        }
      });
    }
    
    // ==========================================================================
    // FORM HANDLING FUNCTIONS
    // ==========================================================================
    
    /**
     * Open the RSVP modal
     */
    function openRsvpModal() {
      nameInput.value = ""; // Clear the name input
      modalOverlay.style.display = "flex";
      rsvpFormContainer.style.display = "block";
      successMessage.style.display = "none";
      updateGuestNamesVisibility();
    }

    /**
     * Close the modal
     */
    function closeModal() {
      modalOverlay.style.display = "none";
      // Reset form
      rsvpForm.reset();
    }
    
    /**
     * Toggle guest count and names visibility based on attendance selection
     */
    function updateGuestNamesVisibility() {
      const guestCount = parseInt(guestsInput.value, 10);
      if (guestCount > 1 && (attendingYes.checked || attendingMaybe.checked)) {
        guestNamesSection.style.display = "block";
      } else {
        guestNamesSection.style.display = "none";
      }
    }
    
    // ==========================================================================
    // EVENT LISTENERS
    // ==========================================================================
    
    // Open RSVP form when the button is clicked
    openRsvpBtn.addEventListener("click", openRsvpModal);

    // Attach close event to the modal's close button
    document.getElementById("closeModal").addEventListener("click", closeModal);
    
    // Toggle guest count and dietary fields based on attendance
    attendingYes.addEventListener("change", function() {
      guestsGroup.style.display = "block";
      dietaryGroup.style.display = "block";
      updateGuestNamesVisibility();
    });
    
    attendingNo.addEventListener("change", function() {
      guestsGroup.style.display = "none";
      dietaryGroup.style.display = "block";
    });
    
    attendingMaybe.addEventListener("change", function() {
      guestsGroup.style.display = "block";
      dietaryGroup.style.display = "block";
      updateGuestNamesVisibility();
    });
    
    // Show/hide guest names field based on number of guests
    guestsInput.addEventListener("change", updateGuestNamesVisibility);
    guestsInput.addEventListener("input", updateGuestNamesVisibility);
    
    // Handle RSVP form submission
    rsvpForm.addEventListener("submit", function(e) {
      e.preventDefault();
      
      // Get the name from the form
      const name = nameInput.value.trim();
      
      // Check if name is provided
      if (!name) {
        alert("Please enter your name");
        return;
      }
      
      // Prepare form data for submission
      const formData = {
        name: name,
        email: document.getElementById("emailInput").value.trim(),
        phone: document.getElementById("phoneInput").value.trim(),
        attending: document.querySelector('input[name="attending"]:checked').value,
        guests: document.getElementById("guestsInput").value,
        guestNames: document.getElementById("guestNamesInput").value.trim(),
        dietary: document.getElementById("dietaryInput").value.trim(),
        comments: document.getElementById("commentsInput").value.trim()
      };
      
      // Show saving indicator
      const submitBtn = rsvpForm.querySelector('button[type="submit"]');
      const originalBtnText = submitBtn.textContent;
      submitBtn.textContent = "Saving...";
      submitBtn.disabled = true;
      
      // Send to Apps Script API
      fetch(SCRIPT_URL, {
        method: 'POST',
        body: JSON.stringify(formData),
        headers: {
          'Content-Type': 'application/json'
        }
      })
      .then(response => {
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        return response.json();
      })
      .then(response => {
        // Reset button
        submitBtn.textContent = originalBtnText;
        submitBtn.disabled = false;
        
        // Show success message
        rsvpFormContainer.style.display = "none";
        successMessage.style.display = "block";
        
        // Create a new bubble with the person's name (if they're attending)
        if (formData.attending === "Y") {
          // Check if this person already has a bubble
          let hasBubble = false;
          document.querySelectorAll('.bubble').forEach(bubble => {
            if (bubble.getAttribute("data-name") === name) {
              hasBubble = true;
            }
          });
          
          // Only create a new bubble if they don't already have one
          if (!hasBubble) {
            createBubble(name, false);
          }
        }
        
        // Close modal after a delay
        setTimeout(() => {
          closeModal();
        }, 3000);
      })
      .catch(error => {
        // Reset button
        submitBtn.textContent = originalBtnText;
        submitBtn.disabled = false;
        
        // Show error
        alert("Error saving RSVP: " + (error.message || "Unknown error"));
        console.error("RSVP submission error:", error);
      });
    });
    
    // ==========================================================================
    // INITIALIZATION
    // ==========================================================================
    
    // When the page loads, initialize everything
    window.onload = function() {
      // Start the SVG path animation
      requestAnimationFrame(animate);
      
      // Start bubble generation - both movement-based and automatic
      requestAnimationFrame(updateNarwhalBubbles);
      startAutoBubbles(); // Start periodic bubble generation
      
      // Load event details from Apps Script
      loadEventDetails();
      
      // Setup event details toggle
      setupEventDetailsToggle();
      
      // Add empty decoration bubbles
      for (let i = 0; i < 8; i++) {
        const size = Math.floor(Math.random() * 30) + 70; // between 70px and 100px
        const position = findNonOverlappingPosition(size);
        
        const emptyBubble = document.createElement("div");
        emptyBubble.className = "bubble";
        emptyBubble.style.top = position.top + "%";
        emptyBubble.style.left = position.left + "%";
        emptyBubble.style.width = size + "px";
        emptyBubble.style.height = size + "px";
        
        // Make empty bubbles more transparent
        emptyBubble.style.opacity = "0.6";
        
        // Apply custom animation
        applyCustomAnimation(emptyBubble, size);
        
        bubbleContainer.appendChild(emptyBubble);
        existingBubbles.push(emptyBubble);
      }
      
      // Load existing RSVPs from Apps Script
      loadExistingRsvps();
      
      // Start the periodic check for confirmed RSVPs
      checkForConfirmedRsvps();
      setInterval(checkForConfirmedRsvps, 60000); // Check every minute
    };
  </script>
</body>
</html>
